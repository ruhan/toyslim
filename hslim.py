"""
First algorithm trying to use hierarchy (relation between items and subitems) as
a reinforce data to a SLIM W matrix.

It is different of SSLIM (cSLIM and others) because it uses an user->item side
information instead of item side information.
"""
from recommender import slim_recommender
from util import tsv_to_matrix
from metrics import compute_precision
from slim import slim_train
import numpy as np
import json

def handle_user_bias(M):
    """
    Transforms the values of a matrix user->item (explicit evaluations) in
    values weighted by user biases.
    * It is an inplace function.
    """
    # We consider as user bias the mean of nonzero evaluations of each user (0
    # evaluations means that the user don't really evaluate the subitem,
    # because the minimal evaluation is 1)
    for i in range(M.shape[0]):
        user_evaluations = M[i, M[i, :].nonzero()]

        # Avoiding division by zero
        if user_evaluations.any():
            M[i, :] = M[i, :]/np.mean(user_evaluations)

    return M

def generate_subitem_hierarchy(K, W, hierarchy):
    """
    Uses the two item->item matrices learned from item and subitem relations
    (respectively) to generate another matrix (with the same shape of W) but
    with vectors as its values.
    """
    # Remember that both arrays are squared arrays ;)
    kdim = K.shape[0]
    wdim = W.shape[0]

    Wline = np.zeros((wdim, wdim), dtype=object)

    for i in xrange(1, kdim):
        for j in xrange(1, kdim):
            iw = hierarchy(i)
            jw = hierarchy(j)

            # TODO: check why we need it!
            if iw is None or jw is None:
                continue

            if K[i, j] != 0:
                if isinstance(Wline[iw, jw], int) or isinstance(Wline[iw, jw], float):
                    Wline[iw, jw] = [K[i, j]]
                else:
                    Wline[iw, jw].append(K[i, j])

    return Wline

def hierarchy_factory(hierarchy_file):
    """
    Returns a function that can be used to discover the item of a subitem.
    # TODO: normalized information should be generated by toyslim automatically
    """
    hierarchy = json.loads(open(hierarchy_file).read())
    # TODO: in the future, it should be generated automatically by slim, as
    # the first step of all algorithms
    normalized = json.loads(open('data/normalized.json').read())
    inverse_normalized_side = { v:k for k, v in normalized['atracoes'].iteritems() }

    # Inversing hierarchy to simplify our work
    inverse_hierarchy = {}

    for city, attractions in hierarchy.iteritems():
        for attraction in attractions:
            if not attraction in inverse_hierarchy:
                inverse_hierarchy[attraction] = city

    def f(subitem):
        subitem = inverse_hierarchy[int(inverse_normalized_side[subitem])]
        return normalized['cidades'].get(subitem, None)

    return f

def normalize_wline(Wline):
    """
    Make a norm of all vectors contained in each position of the 3d matrix Wline
    and return a new 2D matrix.
    """
    WlineNormalized = np.zeros(Wline.shape)

    for i in xrange(Wline.shape[0]):
        for j in xrange(Wline.shape[1]):
            if Wline[i, j] != 0:
                WlineNormalized[i, j] = np.linalg.norm(Wline[i, j])
    return WlineNormalized

def foo(Wline, value=2):
    """
    FIXME TODO: REMOVE IT!
    """
    for i in xrange(Wline.shape[0]):
        for j in xrange(Wline.shape[1]):
            if isinstance(Wline[i, j], list):
                if len(Wline[i, j]) == 1:
                    Wline[i, j] = 0
    return Wline

def main(train_file, user_sideinformation_file, hierarchy_file, test_file):
    A = tsv_to_matrix(train_file)
    B = tsv_to_matrix(user_sideinformation_file, A.shape[0], A.shape[1])
    hierarchy = hierarchy_factory(hierarchy_file)

    # Learning using SLIM
    # We handle user bias only in B because in B we have explicit evaluations
    K = slim_train(handle_user_bias(B))
    W = slim_train(A)

    Wline = generate_subitem_hierarchy(K, W, hierarchy)
    WlineNorm = normalize_wline(Wline)

    #recommendations = slim_recommender(A, W + 0.2 * WlineNorm)
    import pdb;pdb.set_trace()
    recommendations = slim_recommender(A, WlineNorm)

    # See if the predictor is just of not
    #user_cities = np.array([ map(hierarchy, B[i].nonzero()[0].tolist()) for i in range(B.shape[0]) ])
    #G = tsv_to_matrix(test_file)
    #print 'TEM QUE DAR VAZIO: ', set(G[1].nonzero()[0]) & set(user_cities[1])
    ### ---- FIM REMOVAME

    compute_precision(recommendations, test_file)


if __name__ == '__main__':
    main('data/train_100.tsv', 'data/user_item_side_information_100.tsv',
         'data/hierarchy.json', 'data/test_100.tsv')
